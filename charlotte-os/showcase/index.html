<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Charlotte OS — Knowledge Topology</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 240 240' fill='none' stroke='%23E53E3E' stroke-width='7' stroke-linecap='round' stroke-linejoin='round'%3E%3Cg transform='translate(120,120)'%3E%3Cline x1='0' y1='0' x2='0' y2='-108'/%3E%3Cline x1='0' y1='0' x2='65' y2='-87'/%3E%3Cline x1='0' y1='0' x2='103' y2='-33'/%3E%3Cline x1='0' y1='0' x2='95' y2='50'/%3E%3Cline x1='0' y1='0' x2='40' y2='100'/%3E%3Cline x1='0' y1='0' x2='-40' y2='100'/%3E%3Cline x1='0' y1='0' x2='-95' y2='50'/%3E%3Cline x1='0' y1='0' x2='-103' y2='-33'/%3E%3Cline x1='0' y1='0' x2='-65' y2='-87'/%3E%3Cpath d='M 0,-108 Q 38,-105 65,-87 Q 92,-65 103,-33 Q 108,10 95,50 Q 78,82 40,100 Q 5,110 -40,100 Q -78,82 -95,50 Q -108,10 -103,-33 Q -92,-65 -65,-87 Q -38,-105 0,-108 Z'/%3E%3C/g%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/deck.gl@9.1.4/dist.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Inter', -apple-system, sans-serif; background: #0F0F0F; color: #E8E0E0; height: 100vh; overflow: hidden; display: flex; flex-direction: column; }
    .header { height: 52px; background: #141414; border-bottom: 1px solid #222; display: flex; align-items: center; padding: 0 20px; gap: 12px; flex-shrink: 0; z-index: 20; }
    .header-back { font-size: 12px; color: #555; text-decoration: none; transition: color 0.2s; margin-right: 4px; }
    .header-back:hover { color: #E53E3E; }
    .header-title { font-size: 15px; font-weight: 800; letter-spacing: -0.5px; white-space: nowrap; }
    .header-title span { color: #E53E3E; }
    .phase-indicator { display: flex; gap: 6px; align-items: center; }
    .phase-dot { width: 10px; height: 10px; border-radius: 50%; background: #222; border: 1px solid #333; transition: all 0.5s ease; }
    .phase-dot.lit { border-color: transparent; box-shadow: 0 0 8px var(--glow); }
    .phase-label { font-size: 11px; color: #555; font-family: 'JetBrains Mono', monospace; transition: color 0.5s; margin-left: 4px; }
    .phase-label.ready { color: #68D391; }
    .header-spacer { flex: 1; }
    .header-btn { padding: 5px 12px; background: #1A1A1A; border: 1px solid #333; border-radius: 6px; color: #888; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.15s; font-family: 'Inter', sans-serif; }
    .header-btn:hover { color: #ccc; border-color: #555; }
    .header-btn.active { color: #E53E3E; border-color: #E53E3E; background: rgba(229,62,62,0.08); }
    .key-hint { font-size: 9px; color: #444; font-family: 'JetBrains Mono', monospace; padding: 2px 5px; background: #1A1A1A; border-radius: 3px; border: 1px solid #2A2A2A; }
    .main-area { flex: 1; display: flex; overflow: hidden; }
    /* Left sidebar */
    .left-sidebar { width: 220px; background: #141414; border-right: 1px solid #222; display: flex; flex-direction: column; flex-shrink: 0; overflow: hidden; z-index: 15; }
    .ls-section { padding: 12px; border-bottom: 1px solid #1E1E1E; }
    .ls-title { font-size: 10px; font-weight: 700; color: #555; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
    .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .stat-cell { background: #1A1A1A; border: 1px solid #222; border-radius: 6px; padding: 8px 6px; text-align: center; }
    .stat-num { font-size: 16px; font-weight: 700; color: #E53E3E; }
    .stat-label { font-size: 8px; color: #555; text-transform: uppercase; }
    #health-gauge { display: flex; justify-content: center; padding: 4px 0; }
    .file-tree-wrap { flex: 1; overflow-y: auto; padding: 8px 12px; }
    .ft-dir { font-size: 10px; font-weight: 700; color: #E53E3E; margin-top: 8px; margin-bottom: 2px; font-family: 'JetBrains Mono', monospace; }
    .ft-file { font-size: 10px; color: #777; padding: 3px 6px; border-radius: 4px; cursor: pointer; font-family: 'JetBrains Mono', monospace; display: flex; align-items: center; gap: 4px; transition: background 0.1s; }
    .ft-file:hover { background: #1A1A1A; color: #ccc; }
    .ft-file.active { background: #A855F720; color: #A855F7; }
    .ft-badge { margin-left: auto; font-size: 9px; background: #222; color: #666; padding: 1px 5px; border-radius: 3px; }
    /* Canvas */
    .canvas-container { flex: 1; position: relative; overflow: hidden; }
    #deck-canvas { width: 100%; height: 100%; }
    .tooltip { display: none; position: absolute; pointer-events: none; background: #1A1A1A; border: 1px solid #333; border-radius: 10px; padding: 12px 14px; max-width: 320px; z-index: 30; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
    .tooltip-name { font-size: 13px; font-weight: 700; margin-bottom: 4px; }
    .tooltip-badges { display: flex; gap: 6px; margin-bottom: 6px; flex-wrap: wrap; }
    .tooltip-badge { font-size: 9px; font-weight: 600; padding: 2px 7px; border-radius: 4px; text-transform: uppercase; letter-spacing: 0.3px; }
    .tooltip-comment { font-size: 11px; color: #999; line-height: 1.5; margin-bottom: 4px; }
    .tooltip-file { font-size: 10px; color: #555; font-family: 'JetBrains Mono', monospace; }
    .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #0F0F0F; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 50; gap: 12px; transition: opacity 0.8s ease; }
    .loading-overlay.hidden { opacity: 0; pointer-events: none; }
    .loading-spinner { width: 32px; height: 32px; border: 3px solid #222; border-top-color: #E53E3E; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { font-size: 12px; color: #666; font-family: 'JetBrains Mono', monospace; }
    .legend { position: absolute; bottom: 48px; left: 16px; background: rgba(20,20,20,0.92); border: 1px solid #2A2A2A; border-radius: 10px; padding: 12px 14px; z-index: 15; font-size: 10px; }
    .legend-title { font-size: 9px; font-weight: 700; color: #555; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .legend-item { display: flex; align-items: center; gap: 8px; padding: 2px 0; color: #888; }
    .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    /* Entity detail sidebar */
    #entity-detail { display: none; width: 280px; background: #141414; border-left: 1px solid #222; padding: 16px; overflow-y: auto; flex-shrink: 0; z-index: 15; }
    .ed-close { float: right; background: none; border: none; color: #555; font-size: 18px; cursor: pointer; padding: 0 4px; line-height: 1; }
    .ed-close:hover { color: #E8E0E0; }
    .ed-name { font-size: 15px; font-weight: 700; margin-bottom: 6px; word-break: break-all; }
    .ed-badges { display: flex; gap: 6px; margin-bottom: 10px; flex-wrap: wrap; }
    .ed-badge { font-size: 9px; font-weight: 600; padding: 2px 8px; border-radius: 4px; text-transform: uppercase; }
    .ed-comment { font-size: 11px; color: #999; line-height: 1.5; margin-bottom: 12px; padding: 8px; background: #1A1A1A; border-radius: 6px; border-left: 3px solid #333; }
    .ed-field { font-size: 11px; color: #888; margin-bottom: 4px; }
    .ed-label { color: #666; font-weight: 600; }
    .ed-section { font-size: 10px; font-weight: 700; color: #555; text-transform: uppercase; margin-top: 14px; margin-bottom: 6px; border-top: 1px solid #222; padding-top: 8px; }
    .ed-issue { font-size: 10px; padding: 4px 6px; border-radius: 4px; margin-bottom: 3px; line-height: 1.4; }
    .ed-issue-error { background: #E53E3E15; color: #F56565; }
    .ed-issue-warning { background: #F59E0B15; color: #F59E0B; }
    .ed-issue-info { background: #4A9EE515; color: #4A9EE5; }
    .ed-sev { font-weight: 700; font-size: 9px; margin-right: 4px; }
    .ed-assertion { font-size: 10px; font-family: 'JetBrains Mono', monospace; color: #777; padding: 2px 0; line-height: 1.4; word-break: break-all; }
    /* Dropzone overlay */
    #dropzone { display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #0F0F0FEE; z-index: 40; flex-direction: column; align-items: center; justify-content: center; gap: 16px; padding: 24px; }
    #dropzone.show { display: flex; }
    #dropzone.dragover { background: rgba(168,85,247,0.08); }
    .drop-icon { width: 64px; height: 64px; border: 3px dashed #333; border-radius: 16px; display: flex; align-items: center; justify-content: center; font-size: 28px; color: #555; transition: border-color 0.2s, color 0.2s; }
    .dragover .drop-icon { border-color: #A855F7; color: #A855F7; }
    .drop-title { font-size: 22px; font-weight: 800; letter-spacing: -0.5px; }
    .drop-sub { font-size: 13px; color: #666; }
    .drop-btn { padding: 10px 24px; background: #A855F7; color: #fff; border: none; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; transition: background 0.15s; }
    .drop-btn:hover { background: #9333EA; }
    .drop-divider { display: flex; align-items: center; gap: 16px; width: 100%; max-width: 640px; margin: 4px 0; color: #444; font-size: 11px; font-weight: 600; }
    .drop-divider::before, .drop-divider::after { content: ''; flex: 1; height: 1px; background: #222; }
    .demo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; max-width: 640px; width: 100%; }
    .demo-card { background: #141414; border: 1px solid #222; border-radius: 10px; padding: 16px 14px; cursor: pointer; transition: all 0.15s; text-align: center; }
    .demo-card:hover { border-color: #444; background: #1A1A1A; transform: translateY(-2px); }
    .demo-card-icon { font-size: 28px; margin-bottom: 8px; }
    .demo-card-title { font-size: 12px; font-weight: 700; margin-bottom: 4px; }
    .demo-card-desc { font-size: 10px; color: #666; line-height: 1.4; }
    .demo-card.corpus { border-color: #68D39140; }
    .demo-card.corpus:hover { border-color: #68D391; }
    .demo-card.corpus .demo-card-title { color: #68D391; }
    .drop-convert-link { font-size: 12px; color: #666; margin-top: 4px; cursor: pointer; transition: color 0.15s; }
    .drop-convert-link:hover { color: #A855F7; }
    #load-status { font-size: 11px; color: #888; margin-top: 4px; display: none; }
    /* Converter panel */
    #converter-panel { display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #0F0F0F; z-index: 45; flex-direction: column; }
    #converter-panel.show { display: flex; }
    .conv-header { padding: 16px 24px 12px; border-bottom: 1px solid #222; display: flex; align-items: center; gap: 16px; }
    .conv-header h3 { font-size: 16px; font-weight: 700; }
    .conv-close { background: none; border: none; color: #555; font-size: 18px; cursor: pointer; margin-left: auto; }
    .conv-close:hover { color: #E8E0E0; }
    .conv-format-pills { display: flex; gap: 6px; }
    .conv-pill { padding: 4px 12px; background: #1A1A1A; border: 1px solid #333; border-radius: 4px; font-size: 10px; font-weight: 600; color: #888; cursor: pointer; transition: all 0.15s; }
    .conv-pill:hover { color: #ccc; border-color: #555; }
    .conv-pill.active { color: #A855F7; border-color: #A855F7; background: #A855F710; }
    .conv-body { flex: 1; display: flex; overflow: hidden; }
    .conv-input-pane { flex: 1; display: flex; flex-direction: column; border-right: 1px solid #222; }
    .conv-pane-header { padding: 8px 16px; font-size: 10px; font-weight: 700; color: #555; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #1E1E1E; display: flex; align-items: center; gap: 8px; }
    .conv-upload-btn { margin-left: auto; padding: 3px 10px; background: #1A1A1A; border: 1px solid #333; border-radius: 4px; font-size: 10px; color: #888; cursor: pointer; }
    .conv-upload-btn:hover { color: #ccc; border-color: #555; }
    #conv-input { flex: 1; background: transparent; border: none; color: #E8E0E0; padding: 16px; font-family: 'JetBrains Mono', monospace; font-size: 12px; line-height: 1.6; resize: none; outline: none; }
    #conv-input::placeholder { color: #444; }
    .conv-output-pane { flex: 1; display: flex; flex-direction: column; }
    #conv-output { flex: 1; background: transparent; border: none; color: #68D391; padding: 16px; font-family: 'JetBrains Mono', monospace; font-size: 12px; line-height: 1.6; resize: none; outline: none; }
    .conv-footer { padding: 10px 24px; border-top: 1px solid #222; display: flex; align-items: center; gap: 16px; }
    .conv-size { font-size: 11px; color: #888; }
    .conv-size strong { color: #E8E0E0; }
    .conv-footer .conv-spacer { flex: 1; }
    .conv-dl-btn { padding: 8px 20px; background: #A855F7; color: #fff; border: none; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; transition: background 0.15s; }
    .conv-dl-btn:hover { background: #9333EA; }
    .conv-dl-btn:disabled { background: #333; color: #666; cursor: not-allowed; }
    .conv-load-btn { padding: 8px 20px; background: #1A1A1A; color: #ccc; border: 1px solid #333; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; }
    .conv-load-btn:hover { border-color: #555; }
    .conv-load-btn:disabled { color: #555; cursor: not-allowed; }
    /* Footer */
    .footer { height: 32px; background: #141414; border-top: 1px solid #222; display: flex; align-items: center; padding: 0 20px; gap: 16px; font-size: 11px; color: #555; flex-shrink: 0; z-index: 20; }
    .footer-stat { display: flex; align-items: center; gap: 4px; }
    .footer-stat strong { color: #E8E0E0; font-weight: 600; }
    .footer-spacer { flex: 1; }
    .footer-brand { font-size: 10px; color: #444; }
    .bb-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .bb-error { background: #E53E3E; }
    .bb-warning { background: #F59E0B; }
    .bb-info { background: #4A9EE5; }
    .bb-orphan { background: #888; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }
    #file-input, #conv-file-input { display: none; }
  </style>
</head>
<body>

<!-- Header -->
<div class="header">
  <a class="header-back" href="../">&larr;</a>
  <div class="header-title"><span>Charlotte OS</span> — Knowledge Topology</div>
  <div class="phase-indicator">
    <div class="phase-dot" id="pd-0" style="--glow:#E53E3E"></div>
    <div class="phase-dot" id="pd-1" style="--glow:#F59E0B"></div>
    <div class="phase-dot" id="pd-2" style="--glow:#4A9EE5"></div>
    <div class="phase-dot" id="pd-3" style="--glow:#A855F7"></div>
    <div class="phase-dot" id="pd-4" style="--glow:#C4A8A8"></div>
    <div class="phase-dot" id="pd-5" style="--glow:#68D391"></div>
  </div>
  <div class="phase-label" id="phase-label">Initializing...</div>
  <div class="header-spacer"></div>
  <button class="header-btn" id="btn-files">+ Files</button>
  <button class="header-btn" id="btn-convert">Convert</button>
  <button class="header-btn" id="btn-heatmap" title="Toggle heatmap">H <span class="key-hint">H</span></button>
  <button class="header-btn" id="btn-arcs" title="Toggle arcs">A <span class="key-hint">A</span></button>
  <button class="header-btn active" id="btn-replay" title="Replay boot">R <span class="key-hint">R</span></button>
</div>

<!-- Main area -->
<div class="main-area">
  <!-- Left sidebar -->
  <div class="left-sidebar">
    <div class="ls-section">
      <div class="ls-title">Stats</div>
      <div class="stat-grid">
        <div class="stat-cell"><div class="stat-num" id="s-files">0</div><div class="stat-label">Files</div></div>
        <div class="stat-cell"><div class="stat-num" id="s-entities">0</div><div class="stat-label">Entities</div></div>
        <div class="stat-cell"><div class="stat-num" id="s-predicates">0</div><div class="stat-label">Predicates</div></div>
        <div class="stat-cell"><div class="stat-num" id="s-rules">0</div><div class="stat-label">Rules</div></div>
        <div class="stat-cell"><div class="stat-num" id="s-mts">0</div><div class="stat-label">Microtheories</div></div>
        <div class="stat-cell"><div class="stat-num" id="s-assertions">0</div><div class="stat-label">Assertions</div></div>
      </div>
    </div>
    <div class="ls-section">
      <div class="ls-title">Health</div>
      <div id="health-gauge"></div>
    </div>
    <div class="ls-section" style="padding-bottom:4px">
      <div class="ls-title">Files</div>
    </div>
    <div class="file-tree-wrap" id="file-tree"></div>
  </div>

  <!-- Canvas -->
  <div class="canvas-container">
    <div id="deck-canvas"></div>
    <div class="tooltip" id="tooltip">
      <div class="tooltip-name" id="tip-name"></div>
      <div class="tooltip-badges" id="tip-badges"></div>
      <div class="tooltip-comment" id="tip-comment"></div>
      <div class="tooltip-file" id="tip-file"></div>
    </div>
    <div class="loading-overlay" id="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loading-text">Loading corpus...</div>
    </div>
    <div class="legend">
      <div class="legend-title">Knowledge Types</div>
      <div class="legend-item"><div class="legend-dot" style="background:#E53E3E"></div> Kernel / Primitives</div>
      <div class="legend-item"><div class="legend-dot" style="background:#4A9EE5"></div> Structural</div>
      <div class="legend-item"><div class="legend-dot" style="background:#68D391"></div> Declarative</div>
      <div class="legend-item"><div class="legend-dot" style="background:#F59E0B"></div> Procedural</div>
      <div class="legend-item"><div class="legend-dot" style="background:#ECC94B"></div> Heuristic</div>
      <div class="legend-item"><div class="legend-dot" style="background:#A855F7"></div> Meta</div>
    </div>
    <!-- Dropzone overlay -->
    <div id="dropzone">
      <div class="drop-icon">&#x25C8;</div>
      <div class="drop-title">Charlotte OS — Knowledge Topology</div>
      <div class="drop-sub">Drop .krf files here or click to browse</div>
      <button class="drop-btn" id="drop-load-btn">Load KRF Files</button>
      <div class="drop-divider">or try a demo</div>
      <div class="demo-grid">
        <div class="demo-card" data-demo="nfl"><div class="demo-card-icon">&#x1F3C8;</div><div class="demo-card-title">NFL Demo</div><div class="demo-card-desc">Teams, players, divisions &amp; rules</div></div>
        <div class="demo-card" data-demo="al-pacino"><div class="demo-card-icon">&#x1F3AC;</div><div class="demo-card-title">Al Pacino</div><div class="demo-card-desc">Films, directors, awards &amp; career</div></div>
        <div class="demo-card" data-demo="board-games"><div class="demo-card-icon">&#x265F;</div><div class="demo-card-title">Board Games</div><div class="demo-card-desc">Games, mechanics, designers &amp; eras</div></div>
        <div class="demo-card corpus" data-demo="corpus"><div class="demo-card-icon">&#x25C8;</div><div class="demo-card-title">Charlotte OS</div><div class="demo-card-desc">Full knowledge corpus (32 files)</div></div>
      </div>
      <div class="drop-convert-link" id="drop-convert-link">Have text or data? Convert to KRF &rarr;</div>
      <div id="load-status"></div>
    </div>
    <!-- Converter panel -->
    <div id="converter-panel">
      <div class="conv-header">
        <h3>Text to KRF Converter</h3>
        <div class="conv-format-pills">
          <div class="conv-pill active" data-format="auto">Auto-detect</div>
          <div class="conv-pill" data-format="text">Plain Text</div>
          <div class="conv-pill" data-format="csv">CSV</div>
          <div class="conv-pill" data-format="json">JSON</div>
        </div>
        <button class="conv-close" id="conv-close-btn">&times;</button>
      </div>
      <div class="conv-body">
        <div class="conv-input-pane">
          <div class="conv-pane-header">Input <button class="conv-upload-btn" id="conv-upload-btn">Upload file</button></div>
          <textarea id="conv-input" placeholder="Paste text, markdown, CSV, or JSON here..."></textarea>
        </div>
        <div class="conv-output-pane">
          <div class="conv-pane-header">KRF Output</div>
          <textarea id="conv-output" readonly></textarea>
        </div>
      </div>
      <div class="conv-footer">
        <div class="conv-size">Estimated size: <strong id="conv-size-val">0 B</strong></div>
        <div class="conv-spacer"></div>
        <button class="conv-load-btn" id="conv-load-viz-btn" disabled>Load in Visualizer</button>
        <button class="conv-dl-btn" id="conv-dl-btn" disabled>Download .krf</button>
      </div>
      <input type="file" id="conv-file-input" accept=".txt,.md,.csv,.json,.tsv">
    </div>
  </div>

  <!-- Entity detail sidebar -->
  <div id="entity-detail"></div>
</div>

<!-- Footer -->
<div class="footer">
  <div class="footer-stat"><span class="bb-dot bb-error"></span> <strong id="err-count">0</strong> errors</div>
  <div class="footer-stat"><span class="bb-dot bb-warning"></span> <strong id="warn-count">0</strong> warnings</div>
  <div class="footer-stat"><span class="bb-dot bb-info"></span> <strong id="info-count">0</strong> info</div>
  <div class="footer-stat"><span class="bb-dot bb-orphan"></span> <strong id="orphan-count">0</strong> orphans</div>
  <div class="footer-spacer"></div>
  <div class="footer-stat">Score: <strong id="health-score">--</strong>/100</div>
  <div class="footer-spacer"></div>
  <div class="footer-stat">Phase <span class="key-hint">1</span>-<span class="key-hint">6</span> filter &nbsp; <span class="key-hint">0</span> all</div>
  <div class="footer-spacer"></div>
  <div class="footer-brand">Powered by deck.gl + luma.gl</div>
</div>

<input type="file" id="file-input" multiple accept=".krf">

<script>
// ════════════════════════════════════════════════════════════════
// KRF PARSER
// ════════════════════════════════════════════════════════════════

class KRFParser {
  constructor() { this.currentMicrotheory = null; }
  tokenize(text) {
    const tokens = []; let i = 0;
    while (i < text.length) {
      const ch = text[i];
      if (/\s/.test(ch)) { i++; continue; }
      if (ch === ';') { const start = i; while (i < text.length && text[i] !== '\n') i++; tokens.push({ type: 'comment', value: text.slice(start, i).replace(/^;+\s*/, '') }); continue; }
      if (ch === '(') { tokens.push({ type: 'lparen' }); i++; continue; }
      if (ch === ')') { tokens.push({ type: 'rparen' }); i++; continue; }
      if (ch === '"') { i++; let str = ''; while (i < text.length && text[i] !== '"') { if (text[i] === '\\' && i + 1 < text.length) { str += text[i + 1]; i += 2; } else { str += text[i]; i++; } } i++; tokens.push({ type: 'string', value: str }); continue; }
      let sym = ''; while (i < text.length && !/[\s()";\r\n]/.test(text[i])) { sym += text[i]; i++; }
      if (sym) { if (/^-?\d+(\.\d+)?$/.test(sym)) tokens.push({ type: 'number', value: parseFloat(sym) }); else tokens.push({ type: 'symbol', value: sym }); }
    }
    return tokens;
  }
  parseExpr(tokens, pos) {
    if (pos >= tokens.length) return [null, pos];
    const tok = tokens[pos];
    if (tok.type === 'lparen') { const list = []; pos++; while (pos < tokens.length && tokens[pos].type !== 'rparen') { const [expr, np] = this.parseExpr(tokens, pos); if (expr !== null) list.push(expr); pos = np; } pos++; return [list, pos]; }
    if (tok.type === 'rparen') return [null, pos + 1];
    if (tok.type === 'comment') return [null, pos + 1];
    return [{ type: tok.type, value: tok.value }, pos + 1];
  }
  av(node) { if (!node || Array.isArray(node)) return null; return node.value !== undefined ? node.value : null; }
  parseFile(text, fileName) {
    const result = { fileName, microtheory: null, assertions: [], rules: [], comments: new Map(), lineComments: [] };
    const lines = text.split('\n'); const tokens = this.tokenize(text); this.currentMicrotheory = null;
    for (let i = 0; i < lines.length; i++) { const line = lines[i].trim(); if (line.startsWith(';;')) result.lineComments.push({ line: i + 1, text: line.replace(/^;+\s*/, '') }); }
    let pos = 0;
    while (pos < tokens.length) { if (tokens[pos].type === 'comment') { pos++; continue; } const [expr, np] = this.parseExpr(tokens, pos); pos = np; if (!expr || !Array.isArray(expr) || expr.length === 0) continue; this._interpret(expr, result); }
    return result;
  }
  _interpret(expr, result) {
    if (!Array.isArray(expr) || expr.length === 0) return;
    const head = this.av(expr[0]); if (!head) return;
    if (head === 'in-microtheory' && expr.length >= 2) { this.currentMicrotheory = this.av(expr[1]); result.microtheory = this.currentMicrotheory; return; }
    if (head === 'comment' && expr.length >= 3) { const target = this.av(expr[1]), text = this.av(expr[2]); if (target && text) result.comments.set(target, text); result.assertions.push({ predicate: 'comment', args: expr.slice(1).map(a => this.av(a)).filter(Boolean), microtheory: this.currentMicrotheory, file: result.fileName }); return; }
    if (head === 'implies' && expr.length >= 3) { const rule = this._parseRule(expr, result); if (rule) result.rules.push(rule); return; }
    if (head === 'defaultTrue' && expr.length >= 2) { const inner = expr[1]; if (Array.isArray(inner) && this.av(inner[0]) === 'implies') { const rule = this._parseRule(inner, result); if (rule) { rule.isDefault = true; result.rules.push(rule); } } return; }
    const args = [];
    for (let i = 1; i < expr.length; i++) { const val = this.av(expr[i]); if (val !== null) args.push(val); else if (Array.isArray(expr[i])) args.push(this._flat(expr[i])); }
    result.assertions.push({ predicate: head, args, microtheory: this.currentMicrotheory, file: result.fileName });
  }
  _parseRule(expr, result) {
    if (expr.length < 3) return null;
    const ant = this._extractPreds(expr[1]), con = this._extractPreds(expr[2]); const vars = new Set(); this._collectVars(expr, vars);
    return { antecedent: ant, consequent: con, variables: [...vars], microtheory: this.currentMicrotheory, file: result.fileName };
  }
  _extractPreds(expr) {
    const preds = []; if (!expr || !Array.isArray(expr)) return preds;
    const head = this.av(expr[0]); if (!head) return preds;
    if (head === 'and' || head === 'or' || head === 'not') { for (let i = 1; i < expr.length; i++) preds.push(...this._extractPreds(expr[i])); return preds; }
    if (head === 'thereExists') { for (let i = 2; i < expr.length; i++) preds.push(...this._extractPreds(expr[i])); return preds; }
    const args = [];
    for (let i = 1; i < expr.length; i++) { const v = this.av(expr[i]); if (v !== null) args.push(v); else if (Array.isArray(expr[i])) { preds.push(...this._extractPreds(expr[i])); args.push('[nested]'); } }
    preds.push({ predicate: head, args }); return preds;
  }
  _collectVars(expr, vars) { if (!expr) return; if (Array.isArray(expr)) { for (const item of expr) this._collectVars(item, vars); } else { const v = this.av(expr); if (v && typeof v === 'string' && v.startsWith('?')) vars.add(v); } }
  _flat(expr) { if (!expr) return ''; if (!Array.isArray(expr)) { const v = this.av(expr); return v !== null ? String(v) : ''; } return '(' + expr.map(e => this._flat(e)).join(' ') + ')'; }
}

// ════════════════════════════════════════════════════════════════
// KRF KNOWLEDGE BASE
// ════════════════════════════════════════════════════════════════

class KRFKnowledgeBase {
  constructor() {
    this.files = new Map(); this.entities = new Map(); this.predicates = new Map(); this.microtheories = new Map();
    this.rules = []; this.assertions = []; this.comments = new Map();
    this.isaMap = new Map(); this.genlsMap = new Map(); this.genlMtMap = new Map();
    this.arityMap = new Map(); this.argIsaMap = new Map(); this.disjointPairs = []; this.fileContributions = new Map();
  }
  addFile(parsed) {
    this.files.set(parsed.fileName, parsed);
    const contrib = { assertionCount: parsed.assertions.length, ruleCount: parsed.rules.length, entities: new Set() };
    if (parsed.microtheory) {
      if (!this.microtheories.has(parsed.microtheory)) this.microtheories.set(parsed.microtheory, { name: parsed.microtheory, files: new Set(), assertionCount: 0 });
      const mt = this.microtheories.get(parsed.microtheory); mt.files.add(parsed.fileName); mt.assertionCount += parsed.assertions.length;
    }
    for (const [key, val] of parsed.comments) this.comments.set(key, val);
    for (const a of parsed.assertions) { this.assertions.push(a); this._indexAssertion(a, contrib); }
    for (const r of parsed.rules) { this.rules.push(r); this._indexRule(r); }
    this.fileContributions.set(parsed.fileName, contrib);
  }
  _indexAssertion(a, contrib) {
    const { predicate, args } = a;
    if (!this.predicates.has(predicate)) this.predicates.set(predicate, { name: predicate, usages: [], declaredArity: null });
    this.predicates.get(predicate).usages.push(a);
    if (predicate === 'isa' && args.length >= 2) {
      const [child, parent] = args; this._ensureEntity(child, a.file); this._ensureEntity(parent, a.file);
      if (!this.isaMap.has(child)) this.isaMap.set(child, new Set()); this.isaMap.get(child).add(parent);
      this.entities.get(child).isaParents.add(parent); this.entities.get(parent).isaChildren.add(child);
      contrib.entities.add(child); contrib.entities.add(parent);
    }
    if (predicate === 'genls' && args.length >= 2) {
      const [child, parent] = args; this._ensureEntity(child, a.file); this._ensureEntity(parent, a.file);
      if (!this.genlsMap.has(child)) this.genlsMap.set(child, new Set()); this.genlsMap.get(child).add(parent);
      this.entities.get(child).genlsParents.add(parent); this.entities.get(parent).genlsChildren.add(child);
      contrib.entities.add(child); contrib.entities.add(parent);
    }
    if (predicate === 'genlMt' && args.length >= 2) {
      const [child, parent] = args;
      if (!this.genlMtMap.has(child)) this.genlMtMap.set(child, new Set()); this.genlMtMap.get(child).add(parent);
      for (const mt of [child, parent]) { if (!this.microtheories.has(mt)) this.microtheories.set(mt, { name: mt, files: new Set(), assertionCount: 0 }); }
    }
    if (predicate === 'arity' && args.length >= 2) {
      const arity = typeof args[1] === 'number' ? args[1] : parseInt(args[1]); this.arityMap.set(args[0], arity);
      if (!this.predicates.has(args[0])) this.predicates.set(args[0], { name: args[0], usages: [], declaredArity: null }); this.predicates.get(args[0]).declaredArity = arity;
    }
    const am = predicate.match(/^arg(\d)Isa$/);
    if (am && args.length >= 2) { if (!this.argIsaMap.has(args[0])) this.argIsaMap.set(args[0], {}); this.argIsaMap.get(args[0])['arg' + am[1] + 'Isa'] = args[1]; }
    if (predicate === 'disjointWith' && args.length >= 2) this.disjointPairs.push({ a: args[0], b: args[1] });
    if (predicate === 'comment' && args.length >= 2) this.comments.set(args[0], args[1]);
    for (const arg of args) { if (typeof arg === 'string' && !arg.startsWith('?') && !arg.startsWith('"') && arg.length > 0) contrib.entities.add(arg); }
  }
  _indexRule(r) { for (const pred of [...r.antecedent, ...r.consequent]) { if (!this.predicates.has(pred.predicate)) this.predicates.set(pred.predicate, { name: pred.predicate, usages: [], declaredArity: null }); } }
  _ensureEntity(name, file) {
    if (!this.entities.has(name)) this.entities.set(name, { name, files: new Set(), isaParents: new Set(), isaChildren: new Set(), genlsParents: new Set(), genlsChildren: new Set(), assertions: [], microtheory: null });
    if (file) this.entities.get(name).files.add(file);
  }
  getTypes(entityName) { const types = new Set(), queue = [entityName]; while (queue.length > 0) { const curr = queue.pop(); const parents = this.isaMap.get(curr); if (parents) for (const p of parents) if (!types.has(p)) { types.add(p); queue.push(p); } } return types; }
  getGeneralizations(entityName) { const genls = new Set(), queue = [entityName]; while (queue.length > 0) { const curr = queue.pop(); const parents = this.genlsMap.get(curr); if (parents) for (const p of parents) if (!genls.has(p)) { genls.add(p); queue.push(p); } } return genls; }
  getKnowledgeType(entityName) {
    for (const a of this.assertions) { if (a.predicate === 'mapsToKnowledgeType' && a.args[0] === entityName) return a.args[1]; }
    const genls = this.getGeneralizations(entityName), types = this.getTypes(entityName), all = new Set([...genls, ...types]);
    if (all.has('EDGE') || all.has('StructuralKnowledge')) return 'StructuralKnowledge';
    if (all.has('NODE') || all.has('DeclarativeKnowledge')) return 'DeclarativeKnowledge';
    if (all.has('PROTOCOL') || all.has('ProceduralKnowledge')) return 'ProceduralKnowledge';
    if (all.has('METRIC') || all.has('SIGNAL') || all.has('HeuristicKnowledge')) return 'HeuristicKnowledge';
    if (all.has('MetaKnowledge')) return 'MetaKnowledge';
    if (all.has('Primitive')) return 'Kernel';
    const entity = this.entities.get(entityName);
    if (entity) for (const f of entity.files) { if (f.includes('structural')) return 'StructuralKnowledge'; if (f.includes('declarative')) return 'DeclarativeKnowledge'; if (f.includes('procedural')) return 'ProceduralKnowledge'; if (f.includes('heuristic')) return 'HeuristicKnowledge'; if (f.includes('meta')) return 'MetaKnowledge'; if (f.includes('kernel')) return 'Kernel'; }
    return null;
  }
  getMtInheritance(mtName) { const visited = new Set(), queue = [mtName]; while (queue.length > 0) { const curr = queue.pop(); if (visited.has(curr)) continue; visited.add(curr); const parents = this.genlMtMap.get(curr); if (parents) for (const p of parents) queue.push(p); } return visited; }
  getAssertionsFor(entityName) { return this.assertions.filter(a => a.args.some(arg => arg === entityName) || a.predicate === entityName); }
  getStats() { return { files: this.files.size, entities: this.entities.size, predicates: this.predicates.size, microtheories: this.microtheories.size, assertions: this.assertions.length, rules: this.rules.length }; }
}

// ════════════════════════════════════════════════════════════════
// KRF ANALYZER
// ════════════════════════════════════════════════════════════════

class KRFAnalyzer {
  constructor(kb) { this.kb = kb; this.issues = []; }
  runAll() { this.issues = []; this._orphans(); this._dangling(); this._arity(); this._chains(); this._mtLeaks(); this._unconnected(); this._missingComments(); return this.issues; }
  _orphans() {
    const referenced = new Set();
    const definitional = new Set(['isa','genls','genlMt','comment','arity','arg1Isa','arg2Isa','arg3Isa','arg4Isa','in-microtheory']);
    for (const r of this.kb.rules) for (const p of [...r.antecedent, ...r.consequent]) { for (const a of p.args) if (typeof a === 'string' && !a.startsWith('?')) referenced.add(a); referenced.add(p.predicate); }
    for (const a of this.kb.assertions) if (!definitional.has(a.predicate)) { for (const arg of a.args) if (typeof arg === 'string' && !arg.startsWith('?')) referenced.add(arg); referenced.add(a.predicate); }
    for (const [name, entity] of this.kb.entities) {
      if (name.startsWith('?') || name.startsWith(':') || name.startsWith('"') || name.endsWith('Mt') || this.kb.microtheories.has(name)) continue;
      if (entity.isaChildren.size > 0 || entity.genlsChildren.size > 0) continue;
      if (referenced.has(name)) continue;
      if (entity.isaParents.size > 0 || entity.genlsParents.size > 0) {
        const hasNonDef = this.kb.assertions.some(a => !definitional.has(a.predicate) && a.args.some(arg => arg === name));
        if (!hasNonDef) this.issues.push({ type: 'orphan', severity: 'warning', entity: name, message: '"' + name + '" defined but never used', file: [...entity.files][0] || '' });
      }
    }
  }
  _dangling() {
    const defined = new Set();
    for (const [n] of this.kb.isaMap) defined.add(n); for (const [, p] of this.kb.isaMap) for (const v of p) defined.add(v);
    for (const [n] of this.kb.genlsMap) defined.add(n); for (const [, p] of this.kb.genlsMap) for (const v of p) defined.add(v);
    for (const [n] of this.kb.arityMap) defined.add(n); for (const [n] of this.kb.microtheories) defined.add(n);
    const sys = new Set(['isa','genls','genlMt','comment','arity','arg1Isa','arg2Isa','arg3Isa','arg4Isa','in-microtheory','disjointWith','implies','and','or','not','thereExists','defaultTrue','equals','lessThan','greaterThan','lessThanOrEqual','greaterThanOrEqual','greaterThanOrEqualTo','plus','minus','times','absoluteDifference']);
    for (const r of this.kb.rules) for (const p of [...r.antecedent, ...r.consequent]) {
      if (!sys.has(p.predicate) && !defined.has(p.predicate) && !p.predicate.startsWith('?')) {
        const hasDef = this.kb.assertions.some(a => (a.predicate === 'isa' || a.predicate === 'arity') && a.args[0] === p.predicate);
        if (!hasDef) { defined.add(p.predicate); this.issues.push({ type: 'dangling', severity: 'info', entity: p.predicate, message: 'Predicate "' + p.predicate + '" used but undeclared', file: r.file || '' }); }
      }
    }
  }
  _arity() {
    for (const [pred, arity] of this.kb.arityMap) {
      const p = this.kb.predicates.get(pred); if (!p) continue;
      for (const u of p.usages) { if (u.predicate === pred && u.args.length !== arity) this.issues.push({ type: 'arity-violation', severity: 'error', entity: pred, message: '"' + pred + '" arity ' + arity + ' but used with ' + u.args.length + ' args', file: u.file || '' }); }
    }
  }
  _chains() {
    const protos = [];
    for (const a of this.kb.assertions) if (a.predicate === 'isa' && a.args[1] === 'PROTOCOL') protos.push(a.args[0]);
    for (const proto of protos) {
      if (proto.startsWith('?')) continue;
      const hasTrig = this.kb.assertions.some(a => a.predicate === 'hasTrigger' && a.args[0] === proto);
      if (!hasTrig) this.issues.push({ type: 'broken-chain', severity: 'info', entity: proto, message: 'PROTOCOL "' + proto + '" has no hasTrigger', file: this._ef(proto) });
    }
  }
  _mtLeaks() {
    const entityMt = new Map();
    for (const a of this.kb.assertions) if (a.microtheory && a.predicate === 'isa' && a.args.length >= 2) { if (!entityMt.has(a.args[0])) entityMt.set(a.args[0], new Set()); entityMt.get(a.args[0]).add(a.microtheory); }
    for (const a of this.kb.assertions) {
      if (!a.microtheory) continue; const accessible = this.kb.getMtInheritance(a.microtheory);
      for (const arg of a.args) {
        if (typeof arg !== 'string' || arg.startsWith('?') || arg.startsWith('"')) continue;
        const argMts = entityMt.get(arg); if (!argMts) continue;
        let ok = false; for (const mt of argMts) if (accessible.has(mt)) { ok = true; break; }
        if (!ok) this.issues.push({ type: 'mt-leak', severity: 'warning', entity: arg, message: '"' + arg + '" referenced across microtheory boundary', file: a.file || '' });
      }
    }
  }
  _unconnected() {
    const adj = new Map();
    const addA = (a, b) => { if (!adj.has(a)) adj.set(a, new Set()); if (!adj.has(b)) adj.set(b, new Set()); adj.get(a).add(b); adj.get(b).add(a); };
    for (const [c, ps] of this.kb.isaMap) for (const p of ps) addA(c, p);
    for (const [c, ps] of this.kb.genlsMap) for (const p of ps) addA(c, p);
    const roots = ['FACT', 'Collection', 'Primitive', 'Thing'].filter(r => adj.has(r));
    const reach = new Set(), queue = [...roots];
    while (queue.length > 0) { const c = queue.pop(); if (reach.has(c)) continue; reach.add(c); const ns = adj.get(c); if (ns) for (const n of ns) queue.push(n); }
    let count = 0;
    for (const [name] of adj) { if (!reach.has(name) && !name.startsWith('?') && !name.endsWith('Mt')) { if (++count > 50) break; this.issues.push({ type: 'unconnected', severity: 'warning', entity: name, message: '"' + name + '" has no path to kernel roots', file: this._ef(name) }); } }
  }
  _missingComments() {
    for (const [name] of this.kb.entities) {
      if (name.startsWith('?') || name.startsWith(':') || name.startsWith('"')) continue;
      const types = this.kb.getTypes(name), isC = types.has('Collection') || types.has('KnowledgeType'), isP = this.kb.arityMap.has(name);
      if ((isC || isP) && !this.kb.comments.has(name)) this.issues.push({ type: 'missing-comment', severity: 'info', entity: name, message: (isC ? 'Collection' : 'Predicate') + ' "' + name + '" has no comment', file: this._ef(name) });
    }
  }
  _ef(name) { const e = this.kb.entities.get(name); return (e && e.files.size > 0) ? [...e.files][0] : ''; }
  computeHealthScore() { let s = 100; for (const i of this.issues) { if (i.severity === 'error') s -= 5; else if (i.severity === 'warning') s -= 2; else s -= 0.5; } return Math.max(0, Math.round(s * 10) / 10); }
  getSummary() { const c = { error: 0, warning: 0, info: 0 }, tc = {}; for (const i of this.issues) { c[i.severity] = (c[i.severity] || 0) + 1; tc[i.type] = (tc[i.type] || 0) + 1; } return { counts: c, typeCounts: tc, score: this.computeHealthScore(), total: this.issues.length }; }
  getIssuesFor(name) { return this.issues.filter(i => i.entity === name); }
}

// ════════════════════════════════════════════════════════════════
// TEXT-TO-KRF CONVERTER
// ════════════════════════════════════════════════════════════════

class TextToKRF {
  constructor() { this.entities = new Set(); this.assertions = []; this.mtName = 'ConvertedMt'; }
  toCamelCase(str) { return str.trim().replace(/[^a-zA-Z0-9\s]/g, '').split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(''); }
  toPredicateCase(str) { const parts = str.trim().replace(/[^a-zA-Z0-9\s]/g, '').split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()); if (parts.length === 0) return 'unknownPred'; parts[0] = parts[0].toLowerCase(); return parts.join(''); }
  detectFormat(text) {
    const trimmed = text.trim();
    if ((trimmed.startsWith('[') && trimmed.endsWith(']')) || (trimmed.startsWith('{') && trimmed.endsWith('}'))) { try { JSON.parse(trimmed); return 'json'; } catch (e) {} }
    const lines = trimmed.split('\n').filter(l => l.trim());
    if (lines.length >= 2) { const fc = (lines[0].match(/,/g) || []).length; if (fc >= 1 && lines.slice(1, 5).every(l => Math.abs((l.match(/,/g) || []).length - fc) <= 1)) return 'csv'; }
    return 'text';
  }
  convert(text, format) {
    this.entities = new Set(); this.assertions = []; this.mtName = 'ConvertedMt';
    if (format === 'auto') format = this.detectFormat(text);
    if (format === 'json') this._parseJSON(text); else if (format === 'csv') this._parseCSV(text); else this._parseText(text);
    return this._render();
  }
  _parseText(text) {
    const lines = text.split('\n'); let indentStack = [];
    for (const line of lines) {
      const trimmed = line.trim(); if (!trimmed || trimmed.startsWith('//')) continue;
      const hm = trimmed.match(/^(#{1,3})\s+(.+)/);
      if (hm) { this.mtName = this.toCamelCase(hm[2]) + 'Mt'; continue; }
      const im = trimmed.match(/^(.+?)\s+is\s+an?\s+(.+)$/i);
      if (im) { const c = this.toCamelCase(im[1]), p = this.toCamelCase(im[2]); this.entities.add(c); this.entities.add(p); this.assertions.push('(isa ' + c + ' ' + p + ')'); continue; }
      const am = trimmed.match(/^(.+?)\s*(?:->|→)\s*(.+?)(?:\s*:\s*(.+))?$/);
      if (am) { const s = this.toCamelCase(am[1]), t = this.toCamelCase(am[2]), r = am[3] ? this.toPredicateCase(am[3]) : 'relatedTo'; this.entities.add(s); this.entities.add(t); this.assertions.push('(' + r + ' ' + s + ' ' + t + ')'); continue; }
      const kv = trimmed.match(/^([^:]+):\s+(.+)$/);
      if (kv) { const key = this.toPredicateCase(kv[1]), val = kv[2].trim(); if (/^[A-Z]/.test(val) && !/\s/.test(val)) { this.entities.add(this.toCamelCase(val)); this.assertions.push('(' + key + ' ' + this.toCamelCase(val) + ')'); } else if (/^\d+(\.\d+)?$/.test(val)) { this.assertions.push('(' + key + ' ' + val + ')'); } else { this.assertions.push('(' + key + ' "' + val.replace(/"/g, '\\"') + '")'); } continue; }
      const lm = line.match(/^(\s*)([-*])\s+(.+)/);
      if (lm) { const indent = lm[1].length, item = this.toCamelCase(lm[3]); this.entities.add(item); while (indentStack.length > 0 && indentStack[indentStack.length - 1].indent >= indent) indentStack.pop(); if (indentStack.length > 0) this.assertions.push('(genls ' + item + ' ' + indentStack[indentStack.length - 1].name + ')'); else this.assertions.push('(isa ' + item + ' Collection)'); indentStack.push({ indent, name: item }); continue; }
      if (trimmed.length > 0 && trimmed.length < 80 && !trimmed.includes('  ')) { const entity = this.toCamelCase(trimmed); if (entity && entity.length > 1) { this.entities.add(entity); this.assertions.push('(isa ' + entity + ' Thing)'); } }
    }
  }
  _parseCSV(text) {
    const lines = text.split('\n').filter(l => l.trim()); if (lines.length < 2) return;
    const headers = this._splitCSVRow(lines[0]), entityColPred = this.toCamelCase(headers[0]);
    for (let i = 1; i < lines.length; i++) {
      const cells = this._splitCSVRow(lines[i]); if (cells.length === 0) continue;
      const entityName = this.toCamelCase(cells[0]); if (!entityName) continue;
      this.entities.add(entityName); this.assertions.push('(isa ' + entityName + ' ' + entityColPred + ')');
      for (let j = 1; j < headers.length && j < cells.length; j++) { const val = cells[j].trim(); if (!val) continue; const pred = this.toPredicateCase(headers[j]); if (/^\d+(\.\d+)?$/.test(val)) this.assertions.push('(' + pred + ' ' + entityName + ' ' + val + ')'); else this.assertions.push('(' + pred + ' ' + entityName + ' "' + val.replace(/"/g, '\\"') + '")'); }
    }
  }
  _splitCSVRow(line) { const cells = []; let current = '', inQuotes = false; for (let i = 0; i < line.length; i++) { const ch = line[i]; if (ch === '"') { inQuotes = !inQuotes; continue; } if (ch === ',' && !inQuotes) { cells.push(current.trim()); current = ''; continue; } current += ch; } cells.push(current.trim()); return cells; }
  _parseJSON(text) {
    let data; try { data = JSON.parse(text.trim()); } catch (e) { return; }
    if (!Array.isArray(data)) data = [data];
    for (const obj of data) {
      if (typeof obj !== 'object' || obj === null) continue;
      let entityName = null;
      for (const key of ['name','Name','id','ID','title','Title']) { if (obj[key] && typeof obj[key] === 'string') { entityName = this.toCamelCase(obj[key]); break; } }
      if (!entityName) { const fs = Object.values(obj).find(v => typeof v === 'string'); entityName = fs ? this.toCamelCase(fs) : 'Entity' + this.entities.size; }
      this.entities.add(entityName);
      const typeField = obj.type || obj.Type || obj.category || obj.Category;
      if (typeField) { const tn = this.toCamelCase(String(typeField)); this.entities.add(tn); this.assertions.push('(isa ' + entityName + ' ' + tn + ')'); } else { this.assertions.push('(isa ' + entityName + ' Thing)'); }
      for (const [key, val] of Object.entries(obj)) {
        if (['name','Name','id','ID','title','Title','type','Type','category','Category'].includes(key)) continue;
        const pred = this.toPredicateCase(key);
        if (typeof val === 'number') this.assertions.push('(' + pred + ' ' + entityName + ' ' + val + ')');
        else if (typeof val === 'string') { if (/^[A-Z][a-zA-Z]+$/.test(val)) this.assertions.push('(' + pred + ' ' + entityName + ' ' + this.toCamelCase(val) + ')'); else this.assertions.push('(' + pred + ' ' + entityName + ' "' + val.replace(/"/g, '\\"') + '")'); }
        else if (typeof val === 'boolean') this.assertions.push('(' + pred + ' ' + entityName + ' ' + val + ')');
        else if (Array.isArray(val)) { for (const item of val) { if (typeof item === 'string') this.assertions.push('(' + pred + ' ' + entityName + ' "' + item.replace(/"/g, '\\"') + '")'); } }
      }
    }
  }
  _render() {
    const lines = [';;; Auto-converted to KRF by Charlotte OS', '', '(in-microtheory ' + this.mtName + ')', ''];
    const seen = new Set(), unique = []; for (const a of this.assertions) { if (!seen.has(a)) { seen.add(a); unique.push(a); } }
    const isaL = unique.filter(a => a.startsWith('(isa ')), genlsL = unique.filter(a => a.startsWith('(genls ')), otherL = unique.filter(a => !a.startsWith('(isa ') && !a.startsWith('(genls '));
    if (isaL.length > 0) { lines.push(';;; Type Declarations'); lines.push(''); for (const a of isaL) lines.push(a); lines.push(''); }
    if (genlsL.length > 0) { lines.push(';;; Hierarchy'); lines.push(''); for (const a of genlsL) lines.push(a); lines.push(''); }
    if (otherL.length > 0) { lines.push(';;; Assertions'); lines.push(''); for (const a of otherL) lines.push(a); lines.push(''); }
    return lines.join('\n');
  }
}

// ════════════════════════════════════════════════════════════════
// VISUALIZATION CONFIG
// ════════════════════════════════════════════════════════════════

const KC = { Kernel: '#E53E3E', StructuralKnowledge: '#4A9EE5', DeclarativeKnowledge: '#68D391', ProceduralKnowledge: '#F59E0B', HeuristicKnowledge: '#ECC94B', MetaKnowledge: '#A855F7', default: '#888888' };
const KS = { Kernel: 'Kernel', StructuralKnowledge: 'Structural', DeclarativeKnowledge: 'Declarative', ProceduralKnowledge: 'Procedural', HeuristicKnowledge: 'Heuristic', MetaKnowledge: 'Meta' };
const PHASE_MAP = {
  'kernel/': { phase: 1, color: '#E53E3E', name: 'Kernel' },
  'spine/temporal/': { phase: 2, color: '#F59E0B', name: 'Temporal Spine' },
  'spine/spatial/': { phase: 3, color: '#4A9EE5', name: 'Spatial Planes' },
  'knowledge/': { phase: 4, color: '#A855F7', name: 'Knowledge Base' },
  'reference/': { phase: 5, color: '#C4A8A8', name: 'Reference' },
  'agent/': { phase: 6, color: '#68D391', name: 'Agent Identity' }
};

function getPhase(file) { for (const prefix in PHASE_MAP) { if (file.indexOf(prefix) !== -1) return PHASE_MAP[prefix]; } return { phase: 4, color: '#A855F7', name: 'Knowledge Base' }; }

// ════════════════════════════════════════════════════════════════
// STATE
// ════════════════════════════════════════════════════════════════

let kb, analyzer;
const parser = new KRFParser();
const converter = new TextToKRF();
let converterOutput = '';
let deckInstance = null;
let visNodes = [], visEdges = [];
let showHeatmap = true, showArcs = true;
let activePhaseFilter = 0;
let highlightedNode = null, highlightedFile = null;
let bootAnimPhase = 0, bootStartTime = 0;

const KRF_MANIFEST = [
  'README.krf',
  'kernel/primitives.krf', 'kernel/types.krf', 'kernel/valuation-layer.krf', 'kernel/boot.krf',
  'knowledge/structural/taxonomy.krf', 'knowledge/structural/mereology.krf', 'knowledge/structural/relations.krf',
  'knowledge/declarative/entities.krf', 'knowledge/declarative/attributes.krf',
  'knowledge/procedural/protocols.krf', 'knowledge/procedural/constraints.krf', 'knowledge/procedural/storytelling.krf',
  'knowledge/procedural/pitch-narratives.krf', 'knowledge/procedural/market-intelligence.krf',
  'knowledge/procedural/visualization.krf',
  'knowledge/heuristic/defaults.krf', 'knowledge/heuristic/thresholds.krf',
  'knowledge/meta/schema.krf', 'knowledge/meta/provenance.krf', 'knowledge/meta/completeness.krf',
  'spine/temporal/epochs.krf', 'spine/temporal/units.krf', 'spine/temporal/lifecycle.krf', 'spine/temporal/encoding.krf',
  'spine/spatial/geospatial.krf', 'spine/spatial/topological.krf', 'spine/spatial/theoretical.krf',
  'reference/knowledge-primitives.krf', 'reference/convex-hull.krf', 'reference/convex-hull-library.krf',
  'agent/identity.krf', 'agent/observer.krf', 'agent/directives.krf'
];
const DEMO_MANIFESTS = { nfl: ['demos/nfl.krf'], 'al-pacino': ['demos/al-pacino.krf'], 'board-games': ['demos/board-games.krf'] };

// ════════════════════════════════════════════════════════════════
// BUILD VIS GRAPH FROM KB
// ════════════════════════════════════════════════════════════════

function buildVisGraph() {
  const skip = new Set(['Thing','and','or','not','thereExists','implies','defaultTrue','True','False','Integer','String']);
  visNodes = []; visEdges = [];
  const edgeSet = new Set();
  kb.entities.forEach((entity, name) => {
    if (name.startsWith('?') || name.startsWith('"') || skip.has(name)) return;
    const kt = kb.getKnowledgeType(name);
    const color = KC[kt] || KC.default;
    const phase = getPhase([...entity.files][0] || '');
    const comment = kb.comments.get(name) || '';
    let nodeType = 'entity';
    const types = kb.getTypes(name), genls = kb.getGeneralizations(name);
    if (types.has('Primitive') || name === 'FACT') nodeType = 'primitive';
    else if (name.endsWith('Mt') || kb.microtheories.has(name)) nodeType = 'microtheory';
    else if (types.has('PROTOCOL') || genls.has('PROTOCOL')) nodeType = 'protocol';
    else if (kb.arityMap.has(name) || types.has('Predicate')) nodeType = 'predicate';
    else if (types.has('Collection') || types.has('KnowledgeType')) nodeType = 'collection';
    visNodes.push({ name, file: [...entity.files][0] || '', knowledgeType: kt, color, phase, comment, nodeType, x: 0, y: 0, connections: 0, isaParents: [...entity.isaParents], genlsParents: [...entity.genlsParents] });
  });
  const nodeNames = new Set(visNodes.map(n => n.name));
  const addEdge = (source, target, type) => {
    if (!nodeNames.has(source) || !nodeNames.has(target)) return;
    const key = source + '|' + type + '|' + target; if (edgeSet.has(key)) return; edgeSet.add(key);
    visEdges.push({ source, target, type });
  };
  for (const [child, parents] of kb.isaMap) for (const p of parents) addEdge(child, p, 'isa');
  for (const [child, parents] of kb.genlsMap) for (const p of parents) addEdge(child, p, 'genls');
  for (const [child, parents] of kb.genlMtMap) for (const p of parents) addEdge(child, p, 'genlMt');
  // Compute connection counts
  const connMap = new Map();
  for (const e of visEdges) { connMap.set(e.source, (connMap.get(e.source) || 0) + 1); connMap.set(e.target, (connMap.get(e.target) || 0) + 1); }
  for (const n of visNodes) n.connections = connMap.get(n.name) || 0;
}

// ════════════════════════════════════════════════════════════════
// FORCE-DIRECTED LAYOUT
// ════════════════════════════════════════════════════════════════

function forceLayout(width, height) {
  const nodeIndex = {};
  const nodes = visNodes.map((ent, idx) => {
    nodeIndex[ent.name] = idx;
    const angle = Math.random() * Math.PI * 2, radius = Math.random() * Math.min(width, height) * 0.3;
    return { x: width / 2 + Math.cos(angle) * radius, y: height / 2 + Math.sin(angle) * radius, vx: 0, vy: 0, entity: ent };
  });
  const phaseCenters = {};
  const step = (Math.PI * 2) / 6;
  for (let p = 1; p <= 6; p++) { const a = step * (p - 1) - Math.PI / 2; phaseCenters[p] = { x: width / 2 + Math.cos(a) * Math.min(width, height) * 0.2, y: height / 2 + Math.sin(a) * Math.min(width, height) * 0.2 }; }
  for (let iter = 0; iter < 150; iter++) {
    const temp = 1 - iter / 150;
    for (let i = 0; i < nodes.length; i++) for (let j = i + 1; j < nodes.length; j++) {
      let dx = nodes[j].x - nodes[i].x, dy = nodes[j].y - nodes[i].y, dist = Math.sqrt(dx * dx + dy * dy) || 1;
      if (dist < 20) dist = 20; const force = 2000 / (dist * dist) * temp, fx = (dx / dist) * force, fy = (dy / dist) * force;
      nodes[i].vx -= fx; nodes[i].vy -= fy; nodes[j].vx += fx; nodes[j].vy += fy;
    }
    for (const e of visEdges) {
      const si = nodeIndex[e.source], ti = nodeIndex[e.target]; if (si === undefined || ti === undefined) continue;
      let dx = nodes[ti].x - nodes[si].x, dy = nodes[ti].y - nodes[si].y, dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const force = dist * 0.008 * temp, fx = (dx / dist) * force, fy = (dy / dist) * force;
      nodes[si].vx += fx; nodes[si].vy += fy; nodes[ti].vx -= fx; nodes[ti].vy -= fy;
    }
    for (const n of nodes) {
      const phase = n.entity.phase ? n.entity.phase.phase : 4, center = phaseCenters[phase] || phaseCenters[4];
      n.vx += (center.x - n.x) * 0.002 * temp; n.vy += (center.y - n.y) * 0.002 * temp;
      n.vx += (width / 2 - n.x) * 0.001; n.vy += (height / 2 - n.y) * 0.001;
      n.vx *= 0.92; n.vy *= 0.92; n.x += n.vx; n.y += n.vy;
    }
  }
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const n of nodes) { if (n.x < minX) minX = n.x; if (n.x > maxX) maxX = n.x; if (n.y < minY) minY = n.y; if (n.y > maxY) maxY = n.y; }
  const rX = maxX - minX || 1, rY = maxY - minY || 1, pad = 80, scale = Math.min((width - pad * 2) / rX, (height - pad * 2) / rY);
  for (const n of nodes) { n.entity.x = (n.x - minX) * scale + pad - width / 2; n.entity.y = -((n.y - minY) * scale + pad - height / 2); }
}

// ════════════════════════════════════════════════════════════════
// DECK.GL LAYERS
// ════════════════════════════════════════════════════════════════

function hexToRgb(hex) { return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)]; }

function isNodeVisible(d) {
  if (activePhaseFilter > 0 && d.phase && d.phase.phase !== activePhaseFilter) return false;
  if (bootAnimPhase < 7 && (d.phase ? d.phase.phase : 4) > bootAnimPhase) return false;
  return true;
}
function isEdgeVisible(e) {
  const sn = visNodes.find(n => n.name === e.source), tn = visNodes.find(n => n.name === e.target);
  const sp = sn ? (sn.phase ? sn.phase.phase : 4) : 4, tp = tn ? (tn.phase ? tn.phase.phase : 4) : 4;
  if (activePhaseFilter > 0 && sp !== activePhaseFilter && tp !== activePhaseFilter) return false;
  if (bootAnimPhase < 7 && (sp > bootAnimPhase || tp > bootAnimPhase)) return false;
  return true;
}
function isConnectedTo(name, target) { return visEdges.some(e => (e.source === name && e.target === target) || (e.target === name && e.source === target)); }
function isFileMatch(d) { return !highlightedFile || (d.file && d.file === highlightedFile); }
function nodeOpacity(d) {
  if (highlightedFile && !isFileMatch(d)) return 30;
  if (highlightedNode && highlightedNode !== d.name && !isConnectedTo(d.name, highlightedNode)) return 40;
  return 220;
}

function getEdgeData() {
  const nodeMap = new Map(); for (const n of visNodes) nodeMap.set(n.name, n);
  return visEdges.filter(isEdgeVisible).map(e => {
    const s = nodeMap.get(e.source), t = nodeMap.get(e.target); if (!s || !t) return null;
    return { ...e, sx: s.x, sy: s.y, tx: t.x, ty: t.y };
  }).filter(Boolean);
}

function buildLayers() {
  const vn = visNodes.filter(isNodeVisible), ed = getEdgeData(), now = Date.now(), layers = [];
  if (showHeatmap) {
    layers.push(new deck.HeatmapLayer({ id: 'heatmap', data: vn, getPosition: d => [d.x, d.y], getWeight: d => Math.max(1, d.connections), radiusPixels: 80, intensity: 0.6, threshold: 0.05,
      colorRange: [[15,15,15],[40,20,40],[80,30,60],[140,40,80],[200,60,60],[229,62,62]], opacity: 0.4, coordinateSystem: deck.COORDINATE_SYSTEM.CARTESIAN }));
  }
  if (showArcs) {
    layers.push(new deck.ArcLayer({ id: 'arcs', data: ed,
      getSourcePosition: d => [d.sx, d.sy], getTargetPosition: d => [d.tx, d.ty],
      getSourceColor: d => { if (highlightedNode && d.source !== highlightedNode && d.target !== highlightedNode) return [60,60,60,30]; if (d.type === 'genlMt') return [168,85,247,180]; if (d.type === 'genls') return [200,200,200,120]; return [120,120,120,80]; },
      getTargetColor: d => { if (highlightedNode && d.source !== highlightedNode && d.target !== highlightedNode) return [60,60,60,30]; if (d.type === 'genlMt') return [168,85,247,120]; if (d.type === 'genls') return [200,200,200,80]; return [120,120,120,50]; },
      getWidth: d => { if (highlightedNode && (d.source === highlightedNode || d.target === highlightedNode)) return 3; return d.type === 'genlMt' ? 2 : d.type === 'genls' ? 1.5 : 1; },
      getHeight: 0.3, coordinateSystem: deck.COORDINATE_SYSTEM.CARTESIAN, pickable: false,
      updateTriggers: { getSourceColor: [highlightedNode], getTargetColor: [highlightedNode], getWidth: [highlightedNode] } }));
  }
  layers.push(new deck.ScatterplotLayer({ id: 'nodes', data: vn,
    getPosition: d => [d.x, d.y],
    getRadius: d => { const base = 4 + Math.min(d.connections * 1.5, 16); if (highlightedNode === d.name) return base * 1.5; if (highlightedNode && !isConnectedTo(d.name, highlightedNode)) return base * 0.6; return base; },
    getFillColor: d => { const rgb = hexToRgb(d.color); return [rgb[0], rgb[1], rgb[2], nodeOpacity(d)]; },
    getLineColor: d => highlightedNode === d.name ? [255,255,255,200] : [0,0,0,0],
    lineWidthMinPixels: 0, lineWidthMaxPixels: 2, stroked: true, pickable: true, radiusMinPixels: 3, radiusMaxPixels: 30,
    coordinateSystem: deck.COORDINATE_SYSTEM.CARTESIAN,
    updateTriggers: { getRadius: [highlightedNode], getFillColor: [highlightedNode, highlightedFile], getLineColor: [highlightedNode] } }));
  layers.push(new deck.TextLayer({ id: 'labels', data: vn.filter(d => { if (highlightedNode === d.name || (highlightedNode && isConnectedTo(d.name, highlightedNode))) return true; return d.connections >= 4 && isFileMatch(d); }),
    getPosition: d => [d.x, d.y], getText: d => d.name,
    getSize: d => { if (highlightedNode === d.name) return 14; return d.connections >= 8 ? 12 : 10; },
    getColor: d => { if (highlightedNode && highlightedNode !== d.name && !isConnectedTo(d.name, highlightedNode)) return [200,200,200,40]; if (highlightedFile && !isFileMatch(d)) return [200,200,200,30]; return [230,230,230,220]; },
    getTextAnchor: 'middle', getAlignmentBaseline: 'top', getPixelOffset: [0, 14], fontFamily: 'Inter, sans-serif', fontWeight: 600,
    coordinateSystem: deck.COORDINATE_SYSTEM.CARTESIAN,
    updateTriggers: { getSize: [highlightedNode], getColor: [highlightedNode, highlightedFile] } }));
  const pulse = (Math.sin(now / 400) + 1) / 2;
  layers.push(new deck.ScatterplotLayer({ id: 'pulse-rings', data: vn.filter(d => d.knowledgeType === 'ProceduralKnowledge' || d.knowledgeType === 'Kernel'),
    getPosition: d => [d.x, d.y], getRadius: d => 6 + Math.min(d.connections * 1.5, 16) + 4 + pulse * 4,
    getFillColor: [0,0,0,0], getLineColor: d => { const rgb = hexToRgb(d.color); let alpha = Math.floor(40 + pulse * 40); if (highlightedNode && highlightedNode !== d.name) alpha = 10; return [rgb[0], rgb[1], rgb[2], alpha]; },
    lineWidthMinPixels: 1, lineWidthMaxPixels: 2, stroked: true, filled: false, pickable: false, radiusMinPixels: 5, radiusMaxPixels: 40,
    coordinateSystem: deck.COORDINATE_SYSTEM.CARTESIAN, updateTriggers: { getRadius: [now], getLineColor: [now, highlightedNode] } }));
  return layers;
}

function initDeck(w, h) {
  deckInstance = new deck.Deck({
    parent: document.getElementById('deck-canvas'),
    initialViewState: { target: [0, 0], zoom: 0, minZoom: -3, maxZoom: 6 },
    controller: { dragPan: true, scrollZoom: true, doubleClickZoom: true },
    views: new deck.OrthographicView(), layers: buildLayers(), getTooltip: null, onHover: onHover, onClick: onClickCanvas
  });
  requestAnimationFrame(function loop() { if (deckInstance) deckInstance.setProps({ layers: buildLayers() }); requestAnimationFrame(loop); });
}

// ════════════════════════════════════════════════════════════════
// INTERACTION
// ════════════════════════════════════════════════════════════════

function onHover(info) {
  const tip = document.getElementById('tooltip');
  if (info.object) {
    const d = info.object;
    document.getElementById('tip-name').textContent = d.name;
    document.getElementById('tip-comment').textContent = d.comment ? d.comment.substring(0, 200) : '';
    document.getElementById('tip-file').textContent = d.file || '';
    const badges = document.getElementById('tip-badges'); badges.innerHTML = '';
    if (d.knowledgeType) { const b = document.createElement('span'); b.className = 'tooltip-badge'; b.textContent = KS[d.knowledgeType] || d.knowledgeType; b.style.background = d.color + '20'; b.style.color = d.color; badges.appendChild(b); }
    if (d.phase) { const b2 = document.createElement('span'); b2.className = 'tooltip-badge'; b2.textContent = 'Phase ' + d.phase.phase; b2.style.background = d.phase.color + '20'; b2.style.color = d.phase.color; badges.appendChild(b2); }
    tip.style.display = 'block';
    let x = info.x + 16, y = info.y + 16;
    const container = document.querySelector('.canvas-container');
    if (x + 320 > container.offsetWidth) x = info.x - 330;
    if (y + 150 > container.offsetHeight) y = info.y - 160;
    tip.style.left = x + 'px'; tip.style.top = y + 'px';
  } else { tip.style.display = 'none'; }
}

function onClickCanvas(info) {
  if (info.object) {
    const name = info.object.name;
    highlightedNode = highlightedNode === name ? null : name;
    highlightedFile = null;
    document.querySelectorAll('.ft-file').forEach(x => x.classList.remove('active'));
    if (highlightedNode) showEntityDetail(highlightedNode); else closeEntityDetail();
  } else {
    highlightedNode = null; highlightedFile = null;
    document.querySelectorAll('.ft-file').forEach(x => x.classList.remove('active'));
    closeEntityDetail();
  }
}

// ════════════════════════════════════════════════════════════════
// ENTITY DETAIL SIDEBAR
// ════════════════════════════════════════════════════════════════

function showEntityDetail(name) {
  const panel = document.getElementById('entity-detail');
  const node = visNodes.find(n => n.name === name);
  const issues = analyzer ? analyzer.getIssuesFor(name) : [];
  const asserts = kb ? kb.getAssertionsFor(name).slice(0, 20) : [];
  const c = node ? node.color : '#888';
  const kt = node ? (KS[node.knowledgeType] || '') : '';
  const nt = node ? node.nodeType : '';
  panel.style.display = 'block';
  panel.innerHTML =
    '<button class="ed-close" id="ed-close-btn">&times;</button>' +
    '<div class="ed-name">' + name + '</div>' +
    '<div class="ed-badges">' +
      (nt ? '<span class="ed-badge" style="background:' + c + '30;color:' + c + '">' + nt + '</span>' : '') +
      (kt ? '<span class="ed-badge" style="background:' + c + '30;color:' + c + '">' + kt + '</span>' : '') +
    '</div>' +
    (node && node.comment ? '<div class="ed-comment">' + node.comment + '</div>' : '') +
    (node && node.file ? '<div class="ed-field"><span class="ed-label">File:</span> ' + node.file + '</div>' : '') +
    (node && node.isaParents.length ? '<div class="ed-field"><span class="ed-label">isa:</span> ' + node.isaParents.join(', ') + '</div>' : '') +
    (node && node.genlsParents.length ? '<div class="ed-field"><span class="ed-label">genls:</span> ' + node.genlsParents.join(', ') + '</div>' : '') +
    (issues.length ? '<div class="ed-section">Issues (' + issues.length + ')</div>' + issues.map(i => '<div class="ed-issue ed-issue-' + i.severity + '"><span class="ed-sev">' + i.severity.toUpperCase() + '</span>' + i.message + '</div>').join('') : '') +
    (asserts.length ? '<div class="ed-section">Assertions (' + asserts.length + ')</div>' + asserts.map(a => '<div class="ed-assertion">(' + a.predicate + ' ' + a.args.map(x => typeof x === 'string' ? x : JSON.stringify(x)).join(' ') + ')</div>').join('') : '');
  document.getElementById('ed-close-btn').addEventListener('click', () => { highlightedNode = null; closeEntityDetail(); });
}
function closeEntityDetail() { document.getElementById('entity-detail').style.display = 'none'; }

// ════════════════════════════════════════════════════════════════
// BOOT ANIMATION
// ════════════════════════════════════════════════════════════════

const PHASE_NAMES = ['', 'Kernel', 'Temporal Spine', 'Spatial Planes', 'Knowledge Base', 'Reference', 'Agent Identity'];
const PHASE_COLORS = ['', '#E53E3E', '#F59E0B', '#4A9EE5', '#A855F7', '#C4A8A8', '#68D391'];
const PHASE_TIMINGS = [0, 0, 1000, 2000, 3000, 5000, 6000];

function startBootAnimation() {
  bootAnimPhase = 0; bootStartTime = Date.now(); highlightedNode = null; activePhaseFilter = 0;
  for (let i = 0; i < 6; i++) { const dot = document.getElementById('pd-' + i); dot.classList.remove('lit'); dot.style.background = '#222'; dot.style.boxShadow = 'none'; }
  document.getElementById('phase-label').textContent = 'Booting...';
  document.getElementById('phase-label').classList.remove('ready');
  runBootPhase();
}
function runBootPhase() {
  const elapsed = Date.now() - bootStartTime; let phase = 0;
  for (let p = 1; p <= 6; p++) { if (elapsed >= PHASE_TIMINGS[p]) phase = p; }
  if (phase > bootAnimPhase) {
    bootAnimPhase = phase;
    const dot = document.getElementById('pd-' + (phase - 1)); dot.classList.add('lit'); dot.style.background = PHASE_COLORS[phase]; dot.style.boxShadow = '0 0 8px ' + PHASE_COLORS[phase] + '60';
    document.getElementById('phase-label').textContent = 'Loading ' + PHASE_NAMES[phase] + '...';
  }
  if (elapsed >= 7000) { bootAnimPhase = 7; document.getElementById('phase-label').textContent = 'Container Operational'; document.getElementById('phase-label').classList.add('ready'); return; }
  requestAnimationFrame(runBootPhase);
}

// ════════════════════════════════════════════════════════════════
// UI UPDATES
// ════════════════════════════════════════════════════════════════

function updateStats() {
  const s = kb.getStats();
  document.getElementById('s-files').textContent = s.files;
  document.getElementById('s-entities').textContent = s.entities;
  document.getElementById('s-predicates').textContent = s.predicates;
  document.getElementById('s-rules').textContent = s.rules;
  document.getElementById('s-mts').textContent = s.microtheories;
  document.getElementById('s-assertions').textContent = s.assertions;
}

function drawHealthGauge(score) {
  const g = document.getElementById('health-gauge'), r = 40, c = 2 * Math.PI * r;
  const off = c * (1 - score / 100), co = score >= 80 ? '#68D391' : score >= 60 ? '#F59E0B' : '#E53E3E';
  g.innerHTML = '<svg width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="' + r + '" fill="none" stroke="#222" stroke-width="6"/><circle cx="50" cy="50" r="' + r + '" fill="none" stroke="' + co + '" stroke-width="6" stroke-dasharray="' + c + '" stroke-dashoffset="' + off + '" transform="rotate(-90 50 50)" stroke-linecap="round"/><text x="50" y="48" text-anchor="middle" fill="' + co + '" font-size="18" font-weight="700" font-family="Inter">' + score + '</text><text x="50" y="62" text-anchor="middle" fill="#666" font-size="9" font-family="Inter">/ 100</text></svg>';
}

function updateBottomBar() {
  const s = analyzer.getSummary();
  document.getElementById('err-count').textContent = s.counts.error || 0;
  document.getElementById('warn-count').textContent = s.counts.warning || 0;
  document.getElementById('info-count').textContent = s.counts.info || 0;
  document.getElementById('orphan-count').textContent = s.typeCounts.orphan || 0;
  document.getElementById('health-score').textContent = s.score;
  drawHealthGauge(s.score);
}

function updateFileTree() {
  const tree = document.getElementById('file-tree'); tree.innerHTML = '';
  const files = [...kb.files.keys()].sort(), dirs = {};
  for (const f of files) { const parts = f.split('/'), dir = parts.length > 1 ? parts.slice(0, -1).join('/') : '', name = parts[parts.length - 1]; if (!dirs[dir]) dirs[dir] = []; dirs[dir].push({ name, fullPath: f }); }
  for (const [dir, list] of Object.entries(dirs).sort()) {
    if (dir) { const d = document.createElement('div'); d.className = 'ft-dir'; d.textContent = dir + '/'; tree.appendChild(d); }
    for (const f of list) {
      const el = document.createElement('div'); el.className = 'ft-file'; el.textContent = f.name; el.title = f.fullPath;
      const contrib = kb.fileContributions.get(f.fullPath);
      if (contrib) { const b = document.createElement('span'); b.className = 'ft-badge'; b.textContent = contrib.assertionCount; el.appendChild(b); }
      el.addEventListener('click', () => {
        document.querySelectorAll('.ft-file').forEach(x => x.classList.remove('active'));
        el.classList.add('active');
        highlightedFile = (highlightedFile === f.fullPath) ? null : f.fullPath;
        highlightedNode = null; closeEntityDetail();
        if (!highlightedFile) el.classList.remove('active');
      });
      tree.appendChild(el);
    }
  }
}

// ════════════════════════════════════════════════════════════════
// CONVERTER UI
// ════════════════════════════════════════════════════════════════

function formatFileSize(bytes) { if (bytes < 1024) return bytes + ' B'; if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'; return (bytes / (1024 * 1024)).toFixed(1) + ' MB'; }

function runConverter() {
  const input = document.getElementById('conv-input').value;
  const pill = document.querySelector('.conv-pill.active'), format = pill ? pill.dataset.format : 'auto';
  const output = document.getElementById('conv-output'), sizeEl = document.getElementById('conv-size-val');
  if (!input.trim()) { output.value = ''; sizeEl.textContent = '0 B'; converterOutput = ''; document.getElementById('conv-dl-btn').disabled = true; document.getElementById('conv-load-viz-btn').disabled = true; return; }
  converterOutput = converter.convert(input, format);
  output.value = converterOutput; sizeEl.textContent = formatFileSize(new Blob([converterOutput]).size);
  document.getElementById('conv-dl-btn').disabled = false; document.getElementById('conv-load-viz-btn').disabled = false;
}

function downloadKRF() {
  if (!converterOutput) return;
  const blob = new Blob([converterOutput], { type: 'text/plain' }), url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = converter.mtName.replace('Mt', '') + '.krf';
  document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
}

function loadConverterOutput() {
  if (!converterOutput || !kb) return;
  const parsed = parser.parseFile(converterOutput, converter.mtName.replace('Mt', '') + '.krf');
  kb.addFile(parsed);
  analyzer = new KRFAnalyzer(kb); analyzer.runAll();
  buildVisGraph();
  const container = document.querySelector('.canvas-container');
  forceLayout(container.offsetWidth, container.offsetHeight);
  updateStats(); updateFileTree(); updateBottomBar();
  document.getElementById('converter-panel').classList.remove('show');
}

// ════════════════════════════════════════════════════════════════
// CORPUS LOADER
// ════════════════════════════════════════════════════════════════

async function loadCorpus() {
  kb = new KRFKnowledgeBase();
  const loadingText = document.getElementById('loading-text');
  const base = window.location.pathname.includes('/showcase') ? '../' : '';
  let loaded = 0, failed = 0;
  for (const path of KRF_MANIFEST) {
    try { const resp = await fetch(base + path); if (!resp.ok) throw new Error(resp.status); const text = await resp.text(); kb.addFile(parser.parseFile(text, path)); loaded++; }
    catch (e) { failed++; console.warn('Failed: ' + path, e); }
    loadingText.textContent = 'Loading ' + (loaded + failed) + '/' + KRF_MANIFEST.length + (failed ? ' (' + failed + ' failed)' : '') + '...';
  }
  if (kb.files.size === 0) { loadingText.textContent = 'No files loaded. Serve from charlotte-os/ root.'; return; }
  loadingText.textContent = 'Analyzing...'; await new Promise(r => setTimeout(r, 50));
  analyzer = new KRFAnalyzer(kb); analyzer.runAll();
  loadingText.textContent = 'Building graph...'; await new Promise(r => setTimeout(r, 50));
  buildVisGraph();
  loadingText.textContent = 'Computing layout...'; await new Promise(r => setTimeout(r, 50));
  const container = document.querySelector('.canvas-container');
  forceLayout(container.offsetWidth, container.offsetHeight);
  updateStats(); updateFileTree(); updateBottomBar();
  loadingText.textContent = 'Rendering...'; await new Promise(r => setTimeout(r, 50));
  initDeck(container.offsetWidth, container.offsetHeight);
  document.getElementById('loading').classList.add('hidden');
  document.getElementById('btn-heatmap').classList.add('active');
  document.getElementById('btn-arcs').classList.add('active');
  startBootAnimation();
}

async function loadDemoOrCorpus(manifest, label) {
  const statusEl = document.getElementById('load-status'); statusEl.style.display = 'block'; statusEl.textContent = 'Loading ' + label + '...';
  kb = new KRFKnowledgeBase();
  const base = window.location.pathname.includes('/showcase') ? '../' : '';
  let loaded = 0, failed = 0;
  for (const path of manifest) {
    try { const resp = await fetch(base + path); if (!resp.ok) throw new Error(resp.status); kb.addFile(parser.parseFile(await resp.text(), path)); loaded++; }
    catch (e) { failed++; }
    statusEl.textContent = 'Loading ' + (loaded + failed) + '/' + manifest.length + '...';
  }
  if (kb.files.size === 0) { statusEl.textContent = 'No files loaded. Serve from charlotte-os/ root.'; return; }
  analyzer = new KRFAnalyzer(kb); analyzer.runAll();
  buildVisGraph();
  const container = document.querySelector('.canvas-container');
  forceLayout(container.offsetWidth, container.offsetHeight);
  updateStats(); updateFileTree(); updateBottomBar();
  if (!deckInstance) initDeck(container.offsetWidth, container.offsetHeight);
  document.getElementById('loading').classList.add('hidden');
  document.getElementById('dropzone').classList.remove('show');
  document.getElementById('btn-heatmap').classList.add('active');
  document.getElementById('btn-arcs').classList.add('active');
  startBootAnimation();
}

async function loadUserFiles(fileList) {
  if (!kb) kb = new KRFKnowledgeBase();
  for (const file of fileList) { if (!file.name.endsWith('.krf')) continue; const text = await file.text(); kb.addFile(parser.parseFile(text, file.name)); }
  analyzer = new KRFAnalyzer(kb); analyzer.runAll();
  buildVisGraph();
  const container = document.querySelector('.canvas-container');
  forceLayout(container.offsetWidth, container.offsetHeight);
  updateStats(); updateFileTree(); updateBottomBar();
  if (!deckInstance) initDeck(container.offsetWidth, container.offsetHeight);
  document.getElementById('loading').classList.add('hidden');
  document.getElementById('dropzone').classList.remove('show');
  startBootAnimation();
}

// ════════════════════════════════════════════════════════════════
// KEYBOARD & EVENTS
// ════════════════════════════════════════════════════════════════

document.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if (key === 'h') { showHeatmap = !showHeatmap; document.getElementById('btn-heatmap').classList.toggle('active', showHeatmap); }
  if (key === 'a') { showArcs = !showArcs; document.getElementById('btn-arcs').classList.toggle('active', showArcs); }
  if (key === 'r') startBootAnimation();
  if (key >= '0' && key <= '6') { activePhaseFilter = parseInt(key); highlightedNode = null; }
  if (key === 'escape') { highlightedNode = null; highlightedFile = null; closeEntityDetail(); document.getElementById('converter-panel').classList.remove('show'); document.getElementById('dropzone').classList.remove('show'); document.querySelectorAll('.ft-file').forEach(x => x.classList.remove('active')); }
});

document.addEventListener('DOMContentLoaded', () => {
  // Header buttons
  document.getElementById('btn-heatmap').addEventListener('click', function() { showHeatmap = !showHeatmap; this.classList.toggle('active', showHeatmap); });
  document.getElementById('btn-arcs').addEventListener('click', function() { showArcs = !showArcs; this.classList.toggle('active', showArcs); });
  document.getElementById('btn-replay').addEventListener('click', () => startBootAnimation());
  document.getElementById('btn-files').addEventListener('click', () => {
    if (kb && kb.files.size > 0) document.getElementById('file-input').click();
    else document.getElementById('dropzone').classList.add('show');
  });
  document.getElementById('btn-convert').addEventListener('click', () => document.getElementById('converter-panel').classList.toggle('show'));
  document.getElementById('conv-close-btn').addEventListener('click', () => document.getElementById('converter-panel').classList.remove('show'));

  // File input
  document.getElementById('file-input').addEventListener('change', e => { if (e.target.files.length > 0) loadUserFiles(e.target.files); e.target.value = ''; });

  // Dropzone
  const dz = document.getElementById('dropzone');
  document.getElementById('drop-load-btn').addEventListener('click', () => document.getElementById('file-input').click());
  dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('dragover'); });
  dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
  dz.addEventListener('drop', e => {
    e.preventDefault(); dz.classList.remove('dragover');
    const files = []; if (e.dataTransfer.items) for (const item of e.dataTransfer.items) { if (item.kind === 'file') { const f = item.getAsFile(); if (f.name.endsWith('.krf')) files.push(f); } }
    if (files.length > 0) loadUserFiles(files);
  });
  document.querySelectorAll('.demo-card').forEach(card => {
    card.addEventListener('click', () => {
      const demo = card.dataset.demo;
      if (demo === 'corpus') loadDemoOrCorpus(KRF_MANIFEST, 'Charlotte OS corpus');
      else if (DEMO_MANIFESTS[demo]) loadDemoOrCorpus(DEMO_MANIFESTS[demo], card.querySelector('.demo-card-title').textContent);
    });
  });
  document.getElementById('drop-convert-link').addEventListener('click', () => { document.getElementById('dropzone').classList.remove('show'); document.getElementById('converter-panel').classList.add('show'); });

  // Converter
  let convTimer = null;
  document.getElementById('conv-input').addEventListener('input', () => { clearTimeout(convTimer); convTimer = setTimeout(runConverter, 200); });
  document.querySelectorAll('.conv-pill').forEach(pill => { pill.addEventListener('click', () => { document.querySelectorAll('.conv-pill').forEach(p => p.classList.remove('active')); pill.classList.add('active'); runConverter(); }); });
  document.getElementById('conv-upload-btn').addEventListener('click', () => document.getElementById('conv-file-input').click());
  document.getElementById('conv-file-input').addEventListener('change', async e => {
    if (e.target.files.length === 0) return; const file = e.target.files[0], text = await file.text();
    document.getElementById('conv-input').value = text;
    const ext = file.name.split('.').pop().toLowerCase(); let format = 'auto';
    if (ext === 'csv' || ext === 'tsv') format = 'csv'; else if (ext === 'json') format = 'json'; else if (ext === 'txt' || ext === 'md') format = 'text';
    document.querySelectorAll('.conv-pill').forEach(p => p.classList.toggle('active', p.dataset.format === format));
    runConverter(); e.target.value = '';
  });
  document.getElementById('conv-dl-btn').addEventListener('click', downloadKRF);
  document.getElementById('conv-load-viz-btn').addEventListener('click', loadConverterOutput);

  // Auto-load
  if (window.location.protocol.startsWith('http')) {
    loadCorpus();
  } else {
    document.getElementById('loading').classList.add('hidden');
    document.getElementById('dropzone').classList.add('show');
  }
});
</script>
</body>
</html>
